### Início do arquivo: auth.cpp ###
#include "auth.hpp"
#include <iostream>
#include <map>
#include <openssl/sha.h>

// Mapa para armazenar as credenciais dos usuários (substituir por banco de dados real)
std::map<std::string, std::string> user_db;  // username -> hashed_password
std::map<std::string, std::string> session_tokens;  // token -> username

// Função para registrar um novo usuário
bool register_user(const std::string& username, const std::string& password) {
    if (user_db.find(username) != user_db.end()) {
        std::cerr << "Usuário já registrado." << std::endl;
        return false;
    }

    // Hash da senha (SHA-256)
    unsigned char hash[SHA256_DIGEST_LENGTH];
    SHA256(reinterpret_cast<const unsigned char*>(password.c_str()), password.size(), hash);
    std::string hashed_password(reinterpret_cast<char*>(hash), SHA256_DIGEST_LENGTH);

    // Armazenar o usuário e a senha no "banco de dados"
    user_db[username] = hashed_password;
    return true;
}

// Função para autenticar um usuário
std::string authenticate_user(const std::string& username, const std::string& password) {
    auto it = user_db.find(username);
    if (it == user_db.end()) {
        std::cerr << "Usuário não encontrado." << std::endl;
        return "";
    }

    // Verificação de senha
    unsigned char hash[SHA256_DIGEST_LENGTH];
    SHA256(reinterpret_cast<const unsigned char*>(password.c_str()), password.size(), hash);
    std::string hashed_password(reinterpret_cast<char*>(hash), SHA256_DIGEST_LENGTH);

    if (it->second == hashed_password) {
        std::string token = generate_session_token(username);
        session_tokens[token] = username;
        return token;
    }

    std::cerr << "Senha incorreta." << std::endl;
    return "";
}

// Função para gerar um token de sessão
std::string generate_session_token(const std::string& username) {
    // Gerar um token simples baseado em UUID
    return generate_uuid();  // Função reutilizada
}

// Função para validar o token de sessão
bool validate_session_token(const std::string& token) {
    return session_tokens.find(token) != session_tokens.end();
}
### Fim do arquivo: auth.cpp ###

### Início do arquivo: auth.hpp ###
#ifndef AUTH_HPP
#define AUTH_HPP

#include <string>

// Declaração das funções de autenticação
bool register_user(const std::string& username, const std::string& password);
std::string authenticate_user(const std::string& username, const std::string& password);
bool validate_session_token(const std::string& token);

// Função para gerar tokens de sessão
std::string generate_session_token(const std::string& username);

#endif // AUTH_HPP
### Fim do arquivo: auth.hpp ###

### Início do arquivo: database.cpp ###
#include "database.hpp"
#include <iostream>

sqlite3* open_database(const std::string& db_name) {
    sqlite3* db;
    int rc = sqlite3_open(db_name.c_str(), &db);
    if (rc) {
        std::cerr << "Erro ao abrir o banco de dados: " << sqlite3_errmsg(db) << std::endl;
        return nullptr;
    }
    return db;
}

void create_events_table(sqlite3* db) {
    std::string sql = "CREATE TABLE IF NOT EXISTS events ("
                      "id TEXT PRIMARY KEY, "
                      "pubkey TEXT, "
                      "content TEXT, "
                      "sig TEXT, "
                      "created_at INTEGER);";
    char* errmsg;
    int rc = sqlite3_exec(db, sql.c_str(), 0, 0, &errmsg);
    if (rc != SQLITE_OK) {
        std::cerr << "Erro ao criar tabela: " << errmsg << std::endl;
        sqlite3_free(errmsg);
    }
}

void store_event(sqlite3* db, const Event& event) {
    std::string sql = "INSERT INTO events (id, pubkey, content, sig, created_at) VALUES (?, ?, ?, ?, ?);";
    sqlite3_stmt* stmt;
    sqlite3_prepare_v2(db, sql.c_str(), -1, &stmt, nullptr);

    sqlite3_bind_text(stmt, 1, event.id.c_str(), -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, event.pubkey.c_str(), -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 3, event.content.c_str(), -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 4, event.sig.c_str(), -1, SQLITE_STATIC);
    sqlite3_bind_int64(stmt, 5, event.created_at);

    if (sqlite3_step(stmt) != SQLITE_DONE) {
        std::cerr << "Erro ao inserir evento no banco de dados: " << sqlite3_errmsg(db) << std::endl;
    }
    sqlite3_finalize(stmt);
}

std::vector<Event> retrieve_events(sqlite3* db) {
    std::vector<Event> events;
    std::string sql = "SELECT id, pubkey, content, sig, created_at FROM events;";
    sqlite3_stmt* stmt;
    int rc = sqlite3_prepare_v2(db, sql.c_str(), -1, &stmt, nullptr);

    if (rc != SQLITE_OK) {
        std::cerr << "Erro ao preparar consulta: " << sqlite3_errmsg(db) << std::endl;
        return events; // Retornar vetor vazio em caso de erro
    }

    while (sqlite3_step(stmt) == SQLITE_ROW) {
        Event event;
        event.id = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 0));
        event.pubkey = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 1));
        event.content = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 2));
        event.sig = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 3));
        event.created_at = sqlite3_column_int64(stmt, 4);
        events.push_back(event);
    }

    sqlite3_finalize(stmt);
    return events;
}
### Fim do arquivo: database.cpp ###

### Início do arquivo: database.hpp ###
#ifndef DATABASE_HPP
#define DATABASE_HPP

#include <string>
#include <sqlite3.h>
#include "event.hpp"

// Funções de banco de dados
sqlite3* open_database(const std::string& db_name);
void create_events_table(sqlite3* db);
void store_event(sqlite3* db, const Event& event);
std::vector<Event> retrieve_events(sqlite3* db);

#endif // DATABASE_HPP
### Fim do arquivo: database.hpp ###

### Início do arquivo: event.cpp ###
#include "event.hpp"
#include <openssl/sha.h>  // Para SHA256
#include <random>
#include <asio.hpp>
#include <sstream>
#include <cereal/archives/json.hpp>
#include <sstream>
#include "database.hpp" 

// Função para gerar UUIDs únicos
std::string generate_uuid() {
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(0, 15);
    std::uniform_int_distribution<> dis2(8, 11);

    std::stringstream ss;
    ss << std::hex;
    for (int i = 0; i < 8; i++) ss << dis(gen);
    ss << "-";
    for (int i = 0; i < 4; i++) ss << dis(gen);
    ss << "-4";  // UUID version 4
    for (int i = 0; i < 3; i++) ss << dis(gen);
    ss << "-";
    ss << dis2(gen);  // UUID variant 1
    for (int i = 0; i < 3; i++) ss << dis(gen);
    ss << "-";
    for (int i = 0; i < 12; i++) ss << dis(gen);
    return ss.str();
}

// Função que agora gera um UUID único para cada evento
std::string Event::calculate_hash() {
    return generate_uuid();
}

// Implementação fictícia de assinatura
std::string Event::sign_event(const std::string& private_key) {
    return "assinatura";  // Substitua pela lógica real
}

// Função de desserialização com Cereal
Event deserialize(const std::string& data) {
    Event event;
    std::istringstream iss(data);
    {
        cereal::JSONInputArchive archive(iss);
        archive(event);
    }
    return event;
}

// Verificação de assinatura fictícia
bool verify_signature(const Event& event) {
    // Lógica fictícia de verificação
    return true;  // Substitua pela lógica real
}### Fim do arquivo: event.cpp ###

### Início do arquivo: event.hpp ###
#ifndef EVENT_HPP
#define EVENT_HPP

#include <string>
#include <asio.hpp>  // Inclua a biblioteca Asio para usar asio::io_context
#include <vector>
#include <cereal/types/vector.hpp>
#include <cereal/types/string.hpp>

// Estrutura do evento
struct Event {
    std::string id;
    std::string pubkey;
    std::string content;
    std::string sig;
    long created_at;
    std::vector<std::vector<std::string>> tags;

    // Funções para serializar e desserializar eventos
    template<class Archive>
    void serialize(Archive& ar) {
        ar(id, pubkey, content, sig, created_at, tags);
    }

    std::string calculate_hash();  // Gerar o ID do evento (com UUID)
    std::string sign_event(const std::string& private_key);  // Assinar o evento
};

void send_message(asio::io_context& io_context, const std::string& message, const std::string& pubkey);
Event deserialize(const std::string& data);
bool verify_signature(const Event& event);

#endif // EVENT_HPP
### Fim do arquivo: event.hpp ###

### Início do arquivo: log.cpp ###
#include "log.hpp"
#include <fstream>
#include <chrono>
#include <ctime>

// Função para registrar uma ação no log
void log_action(const std::string& action) {
    std::ofstream logfile("log.txt", std::ios_base::app);
    if (!logfile.is_open()) {
        std::cerr << "Erro ao abrir o arquivo de log." << std::endl;
        return;
    }

    // Pegar o timestamp atual
    auto now = std::chrono::system_clock::now();
    std::time_t now_time = std::chrono::system_clock::to_time_t(now);

    // Escrever no log
    logfile << "[" << std::ctime(&now_time) << "] " << action << std::endl;
    logfile.close();
}
### Fim do arquivo: log.cpp ###

### Início do arquivo: log.hpp ###
#ifndef LOG_HPP
#define LOG_HPP

#include <string>

// Função para registrar ações no log
void log_action(const std::string& action);

#endif // LOG_HPP
### Fim do arquivo: log.hpp ###

### Início do arquivo: nostr_client.cpp ###
#include <iostream>
#include <string>
#include <asio.hpp>
#include <cereal/archives/json.hpp>
#include <sstream>
#include "event.hpp"

using asio::ip::tcp;

// Função para enviar uma mensagem/evento
void send_message(asio::io_context& io_context, const std::string& message, const std::string& pubkey) {
    Event event;
    event.pubkey = pubkey;
    event.content = message;
    event.created_at = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());
    event.id = event.calculate_hash();
    event.sig = event.sign_event("minha-chave-privada");

    std::ostringstream oss;
    {
        cereal::JSONOutputArchive archive(oss);
        archive(event);
    }
    std::string serialized_event = oss.str();

    asio::ip::tcp::resolver resolver(io_context);
    auto endpoints = resolver.resolve("127.0.0.1", "8000");
    asio::ip::tcp::socket socket(io_context);
    asio::connect(socket, endpoints);
    asio::write(socket, asio::buffer(serialized_event));
}


int main() {
    asio::io_context io_context;
    std::string message = "Olá, servidor!";
    std::string private_key = "minha-chave-privada";  // Substituir pela chave privada real

    send_message(io_context, message, private_key);

    return 0;
}### Fim do arquivo: nostr_client.cpp ###

### Início do arquivo: nostr_server.cpp ###
#include <iostream>
#include <string>
#include <asio.hpp>
#include <cereal/archives/json.hpp>
#include <sstream>
#include <sqlite3.h>
#include <openssl/pem.h>
#include "event.hpp"
#include "database.hpp" // Certifique-se de que este cabeçalho está correto

using asio::ip::tcp;

// Classe para gerenciar a sessão de cada cliente
class Session : public std::enable_shared_from_this<Session> {
public:
    Session(tcp::socket socket, sqlite3* db)
        : socket_(std::move(socket)), db_(db) {}

    void start() {
        do_read();
    }

private:
    tcp::socket socket_;
    sqlite3* db_;
    char data_[1024]; // Buffer para armazenar dados recebidos

    void do_read() {
        auto self(shared_from_this());
        socket_.async_read_some(asio::buffer(data_),
            [this, self](std::error_code ec, std::size_t length) {
                if (!ec) {
                    std::string received_message(data_, length);
                    Event event = deserialize(received_message);

                    if (verify_signature(event)) {
                        store_event(db_, event);
                        std::cout << "Evento armazenado com sucesso." << std::endl;
                    } else {
                        std::cerr << "Assinatura inválida." << std::endl;
                    }

                    do_read();  // Continue lendo a próxima mensagem
                } else if (ec == asio::error::eof) {
                    std::cerr << "Conexão encerrada pelo cliente." << std::endl;
                } else {
                    std::cerr << "Erro ao ler: " << ec.message() << std::endl;
                }
            });
    }
};

// Classe para gerenciar o servidor
class Server {
public:
    Server(asio::io_context& io_context, short port)
        : acceptor_(io_context, tcp::endpoint(tcp::v4(), port)), db_(open_database("events.db")) {
        create_events_table(db_); // Criar a tabela no início
        do_accept();
    }

private:
    tcp::acceptor acceptor_;
    sqlite3* db_;

    void do_accept() {
        acceptor_.async_accept([this](std::error_code ec, tcp::socket socket) {
            if (!ec) {
                std::make_shared<Session>(std::move(socket), db_)->start();
            }
            do_accept();  // Aceitar a próxima conexão
        });
    }
};

// Função principal
int main() {
    try {
        asio::io_context io_context;
        int port = 8000;  // Defina a porta desejada
        
        Server server(io_context, port);
        std::cout << "Servidor aguardando conexões no porto " << port << "...\n";
        io_context.run();
    } catch (std::exception& e) {
        std::cerr << "Erro: " << e.what() << std::endl;
    }
}### Fim do arquivo: nostr_server.cpp ###

